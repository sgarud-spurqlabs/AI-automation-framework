---
name: requirement_enrichment_instructions
description: Instructions for LLMs and engineers to expand and clarify epics, user stories, and requirements using additional inputs (images, Figma, wireframes, screenshots)
applyTo: "requirements/*EP*.*,requirements/*ST*.*"
---

# Requirement Enrichment — Senior QA / Test Architect Guidance

Purpose
- Act as a senior test architect / QA director (30+ years experience). Given a base epic/user story plus additional inputs (image attachments, Figma URLs, wireframes, screenshots, CSVs), produce an enhanced, crystal-clear requirement artifact suitable for development, QA, and product sign-off.

Primary goals
- Remove ambiguity: specify exact field validations, allowed values, boundary conditions, and error messages.
- Provide comprehensive acceptance criteria and non-functional requirements (performance, security, accessibility, localization, concurrency).

Inputs accepted (ordered by preference)
- Canonical user story or epic text (required)
- Existing acceptance criteria and test-cases (CSV or list)
- Images / screenshots (PNG/JPEG) — annotate where behavior is inferred from visuals
- Figma file or frame URL — include exact component names, styles, and exposed properties
- Wireframes (PDF/SVG) — use positional/layout hints to infer constraints
- Design tokens, CSS snippets, or component libs (optional)

Output formats
- Primary: Markdown (`.md`) with structured sections (see Template below).
- Output path: write to `/requirements/` as `<story-id>-enhanced.md` (e.g., `ORNG-ST-013-enhanced.md`). Create directory if missing.

Template — required sections in each enhanced requirement file
1. Header
   - `OriginalID:` (if present), `Title:`, `Author:`, `Date:`, `AttachmentsReferenced: [list of filenames/URLs]`
2. Summary / Purpose (1–2 lines)
3. Scope (In-scope / Out-of-scope)
4. Detailed Fields & UI Elements (for each input/control)
   - Field name (UI selector if available)
   - Type (text, number, email, date, select, multiselect, checkbox, radio, file upload)
   - Placeholder text (if visible)
   - Required: `true|false`
   - Validation rules (exact):
     - `minLength`, `maxLength` (integers)
     - `regex` (explicit pattern), with examples of accepted and rejected values
     - `type constraints` (numeric range, allowed decimals)
     - `format` (ISO date, RFC3339, email, phone E.164)
   - Boundary values to test (list): include exact numbers/strings for BVA and negative examples
   - Default value (if any)
   - Error messages (exact text) for each validation failure
   - Accessibility notes (aria-labels, role, keyboard focus order)
      - Dropdowns / Selects / Lookup Fields
         - Source of values: static list, API endpoint (path), or dependent on another field
         - Provide canonical list of options where visible or inferred. If unknown, specify query to product ("provide allowed options for Job Title")
         - Default selection and placeholder
         - Multi-select rules (max selections, ordering)

      - Buttons / Actions / Workflows
         - Button text, enabled/disabled conditions, loading state, expected API calls (if known)
         - Modal/dialog confirmation text for destructive actions


7. Acceptance Criteria (numbered)
   - Each AC must be testable and atomic. Use Given/When/Then style where helpful.
   - Include positive and negative ACs; map to fields above.

8. Non-functional Requirements (explicit)
   - Performance: response time targets (e.g., "Search returns first page within 2s under 1000 concurrent users")
   - Scalability / volume: expected dataset sizes, pagination strategy
   - Security: input encoding, max file upload size, allowed content-types, authentication/authorization boundaries
   - Accessibility: WCAG 2.1 AA checklist items that apply (keyboard, labels, contrast ratio) and how to verify
   - Localization: supported locales, date/number formats, max length expansions for translated strings
   - Reliability / retry behavior: idempotency and retry guidance for critical endpoints

9. API & Integration Contracts (if applicable)
   - Endpoint URL(s), request/response schema (examples), status codes for success and failure, error payload structure
   - Expected side-effects (e.g., background jobs, delayed consistency)

10. Test Data & Setup
   - Exact test accounts or seed data required (example values only — do not include real secrets)
   - DB state preconditions and cleanup steps

11. Edge Cases & Decision Tables
   - For combinational logic (e.g., permissions, include/exclude toggles), create a small decision table mapping inputs to expected outputs.
   - For stateful flows, provide a brief state-transition diagram description (states and transitions) or list.

13. Questions / Assumptions
   - List any unanswered questions that require product or design input. Mark them as `QUESTION: ...` and include a suggested resolution or recommended default.

14. Change Log
   - Record what changed from the original story and date/author for each change.

Behavioral rules for the LLM / author
- Always prefer concrete, testable statements over vague language. Replace "should" / "may" with explicit criteria or a QUESTION item asking for clarification.
- When inferring from images or Figma, clearly label inferred items with `INFERRED:` and list the source (filename + visual cue or frame name).
- Provide examples for each validation rule (one accepted, one rejected) to make ACs executable by QA.
- For dropdowns or lookup values: if source is API, include sample request to fetch allowed values.
- For date/time fields: specify timezone behavior (UTC or local) and canonical format.
- For numeric fields: specify units and precision (e.g., currency in cents, 2 decimal places).
- For file uploads: specify max size, allowed mime types, virus-scan expectations, and what to show in UI on failure.

Quality & Tone
- Write as an experienced test architect: concise, professional, and prescriptive. Use bullet lists, tables, and example blocks.
- Keep the document scannable: use numbered sections and short paragraphs.

Operational rules
- File naming: `/requirements/<Original file name>-enhanced.md`.
- If attachments are present, download and inspect them; annotate each inference. If images are low-quality or ambiguous, add a `QUESTION` recommending clarification and an example of what is needed.
- If Figma URL is provided, reference the exact frame/component name in the output and include design tokens if available.

When to ask clarifying questions (examples)
- Missing allowed values for selects
- Unclear error messages or ambiguous success criteria
- Conflicting constraints across different attachments (e.g., wireframe shows maxlength=50 but Figma text token implies 100)

Safety & constraints
- Never invent backend contracts or security behaviors without clearly marking them as `INFERRED` and adding a `QUESTION` to confirm.
- Do not include secrets (API keys, real passwords) in outputs; use placeholders.

Example snippet (field validation)
```
Field: Employee ID (input[name='employeeId'])
Type: text
Required: true
Validation:
  minLength: 3
  maxLength: 10
  regex: "^[A-Z0-9-]+$"
Accepted example: "EMP-001"
Rejected example: "emp@123" (contains invalid char '@')
Error message: "Employee ID must be 3–10 uppercase letters, numbers or hyphens"
```
